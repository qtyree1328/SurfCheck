<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<title>SurfCheck</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=DM+Mono:wght@300;400;500&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css">
<script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#f4f1ec;--card:#fff;--text:#1a1a1a;--muted:#777;--accent:#2563eb;
  --good:#16a34a;--ok:#ca8a04;--bad:#dc2626;--border:#e5e1db;
}
html{font-size:16px}
body{font-family:'Libre Baskerville',Georgia,serif;background:var(--bg);color:var(--text);
  max-width:540px;margin:0 auto;padding:0;line-height:1.5}
.header{padding:16px 16px 0}
h1{font-size:1.6rem;letter-spacing:-0.5px}
.subtitle{font-size:0.8rem;color:var(--muted);font-style:italic;margin-bottom:4px}
#map{width:100%;height:300px;border-bottom:1px solid var(--border)}
.content{padding:0 16px 16px}
h2{font-size:0.85rem;font-weight:400;color:var(--muted);margin:14px 0 8px;
  text-transform:uppercase;letter-spacing:1.5px;font-family:'DM Mono',monospace}
.card{background:var(--card);border-radius:12px;padding:16px;margin-bottom:14px;
  border:1px solid var(--border);box-shadow:0 1px 3px rgba(0,0,0,0.04)}
.card h3{font-size:0.75rem;text-transform:uppercase;letter-spacing:1.2px;
  color:var(--muted);font-family:'DM Mono',monospace;margin-bottom:8px;font-weight:400}
.big-val{font-size:2rem;font-weight:700;line-height:1.1}
.unit{font-size:0.85rem;font-weight:400;color:var(--muted)}
.sub{font-size:0.8rem;color:var(--muted);margin-top:4px;font-family:'DM Mono',monospace}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:14px}
.source{font-size:0.65rem;color:var(--muted);font-family:'DM Mono',monospace;margin-top:6px;opacity:0.7}
canvas{width:100%;border-radius:8px;background:#fff}
.forecast-table{width:100%;border-collapse:collapse;font-family:'DM Mono',monospace;font-size:0.7rem}
.forecast-table th{text-align:left;padding:6px 4px;border-bottom:2px solid var(--border);
  font-weight:500;color:var(--muted);text-transform:uppercase;letter-spacing:0.5px}
.forecast-table td{padding:5px 4px;border-bottom:1px solid var(--border)}
.forecast-table tr:hover{background:rgba(37,99,235,0.04)}
iframe{width:100%;border:none;border-radius:8px}
.loading{color:var(--muted);font-style:italic}
.timestamp{font-size:0.65rem;color:var(--muted);font-family:'DM Mono',monospace;text-align:center;margin:20px 0 10px}
#buoy-name{font-size:1.1rem;font-weight:700;margin:12px 0 2px}
#buoy-meta{font-size:0.75rem;color:var(--muted);font-family:'DM Mono',monospace;margin-bottom:4px}
.search-wrap{position:relative;margin:8px 16px}
#buoy-search{width:100%;padding:8px 12px;border:1px solid var(--border);border-radius:8px;
  font-family:'DM Mono',monospace;font-size:0.8rem;background:var(--card);outline:none}
#buoy-search:focus{border-color:var(--accent)}
#search-results{position:absolute;top:100%;left:0;right:0;background:var(--card);
  border:1px solid var(--border);border-radius:0 0 8px 8px;max-height:200px;overflow-y:auto;
  z-index:1000;display:none;box-shadow:0 4px 12px rgba(0,0,0,0.1)}
#search-results div{padding:8px 12px;cursor:pointer;font-family:'DM Mono',monospace;font-size:0.75rem;
  border-bottom:1px solid var(--border)}
#search-results div:hover{background:rgba(37,99,235,0.06)}
.error-msg{color:var(--bad);font-size:0.8rem;font-family:'DM Mono',monospace;padding:8px 0}
.card.inactive{border-color:#e5c07b;background:#fffdf5}
.card.inactive .big-val{color:var(--ok);font-size:1rem;font-weight:400}
.card.inactive .sub{color:var(--ok)}
#buoy-warning{display:none;background:#fffdf5;border:1px solid #e5c07b;border-radius:10px;
  padding:12px 14px;margin-bottom:14px;font-family:'DM Mono',monospace;font-size:0.8rem;color:#92700c}
</style>
</head>
<body>

<div class="header">
  <h1>SurfCheck</h1>
  <p class="subtitle">Click a buoy on the map or search below</p>
</div>

<div class="search-wrap">
  <input type="text" id="buoy-search" placeholder="Search buoys (e.g. Block Island, 44097)..." autocomplete="off">
  <div id="search-results"></div>
</div>

<div id="map"></div>

<div class="content">
  <div id="buoy-name">Select a buoy</div>
  <div id="buoy-meta"></div>
  <p id="status" class="sub loading"></p>
  <div id="buoy-warning">‚ö†Ô∏è Station inactive ‚Äî no recent buoy data available. Forecast &amp; wind still shown from model data.</div>

  <div class="grid2">
    <div class="card">
      <h3>üåä Current Swell</h3>
      <div id="swell-val" class="big-val">‚Äî</div>
      <div id="swell-detail" class="sub"></div>
      <div class="source">NDBC <span class="buoy-id-ref"></span></div>
    </div>
    <div class="card">
      <h3>üå°Ô∏è Water Temp</h3>
      <div id="temp-val" class="big-val">‚Äî</div>
      <div id="temp-detail" class="sub"></div>
      <div class="source">NDBC <span class="buoy-id-ref"></span></div>
    </div>
  </div>
  <div class="grid2">
    <div class="card">
      <h3>üí® Wind</h3>
      <div id="wind-val" class="big-val">‚Äî</div>
      <div id="wind-detail" class="sub"></div>
      <div class="source" id="wind-source">NWS API</div>
    </div>
    <div class="card">
      <h3>‚òÄÔ∏è Daylight</h3>
      <div id="daylight-val" class="big-val">‚Äî</div>
      <div id="daylight-detail" class="sub"></div>
      <div class="source">Astronomical</div>
    </div>
  </div>

  <div class="card">
    <h3>üåä Tides ‚Äî <span id="tide-station-name">Nearest Station</span></h3>
    <canvas id="tideCanvas" height="180"></canvas>
    <div class="source" id="tide-source">CO-OPS</div>
  </div>

  <div class="card">
    <h3>üß≠ Swell Direction ‚Äî Spectral Compass Rose</h3>
    <canvas id="compassCanvas" height="300"></canvas>
    <div class="sub">Swell energy by direction &amp; frequency</div>
    <div class="source">NDBC <span class="buoy-id-ref"></span> spectral</div>
  </div>

  <div class="card">
    <h3>üìà Swell Forecast</h3>
    <canvas id="forecastCanvas" height="200"></canvas>
    <div class="source">Open-Meteo Marine API</div>
  </div>

  <div class="card">
    <h3>üìã Hourly Forecast Detail</h3>
    <div id="hourly-table"></div>
    <div class="source">Open-Meteo Marine API</div>
  </div>

  <div class="card">
    <h3>üó∫Ô∏è Wind Map</h3>
    <iframe id="windy-iframe" height="400" loading="lazy"></iframe>
    <div class="source">Windy.com ¬∑ ECMWF</div>
  </div>

  <div class="timestamp" id="footer-ts"></div>
</div>

<script>
// =========================================================================
// SurfCheck ‚Äî Fully Client-Side Multi-Buoy App
// =========================================================================

const CORS_PROXY = 'https://corsproxy.io/?';
const $ = id => document.getElementById(id);
const mToFt = m => m != null ? (m * 3.28084) : null;
const cToF = c => c != null ? (c * 9/5 + 32) : null;
const degToCompass = d => {
  if (d == null) return '?';
  const dirs = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'];
  return dirs[Math.round(d / 22.5) % 16];
};
const pad2 = n => String(n).padStart(2, '0');

const MISSING_FLOATS = new Set([99, 99.0, 99.00, 999, 999.0, 9999, 9999.0, 9.9, 9.99]);
function safeFloat(val) {
  if (val == null || val === '' || val === 'MM') return null;
  const f = parseFloat(val);
  if (isNaN(f)) return null;
  if (MISSING_FLOATS.has(f)) return null;
  return f;
}
function safeWaveHeight(val) {
  const f = safeFloat(val);
  if (f != null && f > 8.0) return null;
  return f;
}

let stations = [];
let currentBuoy = null;
let map = null;
let markers = [];

// =========================================================================
// Fetch helpers
// =========================================================================
async function fetchText(url, useCors = false) {
  const target = useCors ? CORS_PROXY + encodeURIComponent(url) : url;
  const resp = await fetch(target);
  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
  return await resp.text();
}

async function fetchNDBC(buoyId, ext) {
  const url = `https://www.ndbc.noaa.gov/data/realtime2/${buoyId}${ext}`;
  try {
    return await fetchText(url, false);
  } catch {
    // NDBC may block CORS ‚Äî try proxy
    return await fetchText(url, true);
  }
}

async function fetchJSON(url) {
  const resp = await fetch(url);
  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
  return await resp.json();
}

// =========================================================================
// Station loading & map
// =========================================================================
async function loadStations() {
  stations = await fetchJSON('data/stations.json');
  return stations;
}

function initMap() {
  map = new maplibregl.Map({
    container: 'map',
    style: {
      version: 8,
      sources: {
        osm: {
          type: 'raster',
          tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
          tileSize: 256,
          attribution: '&copy; OpenStreetMap'
        }
      },
      layers: [{
        id: 'osm',
        type: 'raster',
        source: 'osm'
      }],
      glyphs: 'https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf'
    },
    center: [-71.1, 41.0],
    zoom: 4,
    maxZoom: 14
  });

  map.addControl(new maplibregl.NavigationControl(), 'top-right');

  map.on('load', () => {
    // Add stations as a GeoJSON source
    const geojson = {
      type: 'FeatureCollection',
      features: stations.map(s => ({
        type: 'Feature',
        geometry: { type: 'Point', coordinates: [s.lon, s.lat] },
        properties: { id: s.id, name: s.name, type: s.type }
      }))
    };

    map.addSource('buoys', { type: 'geojson', data: geojson });

    map.addLayer({
      id: 'buoy-circles',
      type: 'circle',
      source: 'buoys',
      paint: {
        'circle-radius': ['interpolate', ['linear'], ['zoom'], 2, 2.5, 6, 4, 10, 7],
        'circle-color': '#2563eb',
        'circle-stroke-width': 1.5,
        'circle-stroke-color': '#fff',
        'circle-opacity': 0.85
      }
    });

    // Selected buoy highlight layer
    map.addLayer({
      id: 'buoy-selected',
      type: 'circle',
      source: 'buoys',
      filter: ['==', ['get', 'id'], ''],
      paint: {
        'circle-radius': ['interpolate', ['linear'], ['zoom'], 2, 5, 6, 8, 10, 12],
        'circle-color': '#dc2626',
        'circle-stroke-width': 2.5,
        'circle-stroke-color': '#fff'
      }
    });

    // Click handler
    map.on('click', 'buoy-circles', (e) => {
      const props = e.features[0].properties;
      selectBuoy(props.id);
    });

    map.on('mouseenter', 'buoy-circles', () => { map.getCanvas().style.cursor = 'pointer'; });
    map.on('mouseleave', 'buoy-circles', () => { map.getCanvas().style.cursor = ''; });

    // Popup on hover
    const popup = new maplibregl.Popup({ closeButton: false, closeOnClick: false, offset: 10 });
    map.on('mouseenter', 'buoy-circles', (e) => {
      const p = e.features[0].properties;
      popup.setLngLat(e.lngLat)
        .setHTML(`<strong>${p.id}</strong><br>${p.name}<br><em>${p.type}</em>`)
        .addTo(map);
    });
    map.on('mouseleave', 'buoy-circles', () => popup.remove());

    // Load from hash or default
    const hashBuoy = location.hash.replace('#', '');
    selectBuoy(hashBuoy || '44097');
  });
}

// =========================================================================
// Search
// =========================================================================
function initSearch() {
  const input = $('buoy-search');
  const results = $('search-results');

  input.addEventListener('input', () => {
    const q = input.value.trim().toLowerCase();
    if (q.length < 2) { results.style.display = 'none'; return; }
    const matches = stations.filter(s =>
      s.id.toLowerCase().includes(q) || s.name.toLowerCase().includes(q)
    ).slice(0, 15);
    if (!matches.length) { results.style.display = 'none'; return; }
    results.innerHTML = matches.map(s =>
      `<div data-id="${s.id}"><strong>${s.id}</strong> ‚Äî ${s.name} <em style="color:#999">${s.type}</em></div>`
    ).join('');
    results.style.display = 'block';
  });

  results.addEventListener('click', (e) => {
    const div = e.target.closest('[data-id]');
    if (div) {
      selectBuoy(div.dataset.id);
      input.value = '';
      results.style.display = 'none';
    }
  });

  input.addEventListener('blur', () => setTimeout(() => results.style.display = 'none', 200));
}

// =========================================================================
// Select Buoy
// =========================================================================
function selectBuoy(buoyId) {
  const station = stations.find(s => s.id === buoyId);
  if (!station) {
    $('buoy-name').textContent = `Buoy ${buoyId} not found`;
    return;
  }

  currentBuoy = station;
  location.hash = buoyId;

  // Update UI
  $('buoy-name').textContent = `${station.name}`;
  $('buoy-meta').textContent = `${station.id} ¬∑ ${station.type} ¬∑ ${station.lat.toFixed(3)}¬∞N, ${Math.abs(station.lon).toFixed(3)}¬∞W`;
  document.querySelectorAll('.buoy-id-ref').forEach(el => el.textContent = station.id);
  $('status').textContent = 'Loading data‚Ä¶';
  $('status').classList.add('loading');

  // Highlight on map
  if (map && map.getLayer('buoy-selected')) {
    map.setFilter('buoy-selected', ['==', ['get', 'id'], buoyId]);
    map.flyTo({ center: [station.lon, station.lat], zoom: 8, duration: 1500 });
  }

  // Update Windy iframe
  $('windy-iframe').src = `https://embed.windy.com/embed.html?type=map&location=coordinates&metricRain=default&metricTemp=default&metricWind=default&zoom=8&overlay=wind&product=ecmwf&level=surface&lat=${station.lat}&lon=${station.lon}`;

  // Fetch all data
  loadAllData(station);
}

// =========================================================================
// Data Loading
// =========================================================================
async function loadAllData(station) {
  // Clear previous state
  ['swell-val','temp-val','wind-val'].forEach(id => { $(id).textContent = '‚Äî'; });
  ['swell-detail','temp-detail','wind-detail'].forEach(id => { $(id).textContent = ''; });
  document.querySelectorAll('.card.inactive').forEach(c => c.classList.remove('inactive'));
  $('buoy-warning').style.display = 'none';

  renderDaylight(station.lat, station.lon);

  const results = await Promise.allSettled([
    loadBuoyData(station),
    loadForecast(station),
    loadTides(station),
    loadWind(station),
  ]);

  const statusParts = [];
  if (results[0].status === 'fulfilled' && results[0].value) statusParts.push('Buoy ‚úì');
  else statusParts.push('Buoy ‚úó');
  if (results[1].status === 'fulfilled' && results[1].value) statusParts.push('Forecast ‚úì');
  else statusParts.push('Forecast ‚úó');
  if (results[2].status === 'fulfilled') statusParts.push('Tides ‚úì');
  else statusParts.push('Tides ‚úó');
  if (results[3].status === 'fulfilled' && results[3].value) statusParts.push('Wind ‚úì');
  else statusParts.push('Wind ‚úó');

  $('status').textContent = statusParts.join(' ¬∑ ');
  $('status').classList.remove('loading');
  $('footer-ts').textContent = `Last loaded: ${new Date().toLocaleString()}`;
}

// =========================================================================
// NDBC Buoy Data
// =========================================================================
async function loadBuoyData(station) {
  let buoyActive = false;
  const swellCard = $('swell-val').closest('.card');
  const tempCard = $('temp-val').closest('.card');

  try {
    const stdmetText = await fetchNDBC(station.id, '.txt');
    const stdmet = parseStdmet(stdmetText);
    if (stdmet && (stdmet.waveHeight_m != null || stdmet.waterTemp_C != null)) {
      buoyActive = true;
    }
    renderSwell(stdmet);
    renderTemp(stdmet);
  } catch (e) {
    console.warn('Buoy stdmet error:', e);
  }

  if (!buoyActive) {
    $('swell-val').textContent = '‚ö†Ô∏è Inactive';
    $('swell-detail').textContent = 'No recent reports';
    $('temp-val').textContent = '‚ö†Ô∏è Inactive';
    $('temp-detail').textContent = '';
    swellCard.classList.add('inactive');
    tempCard.classList.add('inactive');
    $('buoy-warning').style.display = 'block';
  } else {
    swellCard.classList.remove('inactive');
    tempCard.classList.remove('inactive');
    $('buoy-warning').style.display = 'none';
  }

  // Spectral data
  try {
    const [specText, swdirText] = await Promise.all([
      fetchNDBC(station.id, '.data_spec'),
      fetchNDBC(station.id, '.swdir'),
    ]);
    const spectral = parseSpectral(specText, swdirText);
    drawCompass(spectral);
  } catch (e) {
    console.warn('Spectral error:', e);
    drawCompass([]);
  }

  return buoyActive;
}

function parseStdmet(text) {
  const lines = text.trim().split('\n');
  if (lines.length < 3) return null;
  const row = lines[2].split(/\s+/);
  if (row.length < 13) return null;
  return {
    time: `${row[0]}-${row[1]}-${row[2]}T${row[3]}:${row[4]}Z`,
    waveHeight_m: safeWaveHeight(row[8]),
    dominantPeriod_s: safeFloat(row[9]),
    avgPeriod_s: safeFloat(row[10]),
    meanDirection_deg: safeFloat(row[11]),
    pressure_hPa: safeFloat(row[12]),
    airTemp_C: safeFloat(row[13]),
    waterTemp_C: row.length > 14 ? safeFloat(row[14]) : null,
    windDir_deg: safeFloat(row[5]),
    windSpeed_mps: safeFloat(row[6]),
    gust_mps: safeFloat(row[7]),
  };
}

function parseSpectral(specText, swdirText) {
  const specLines = specText.trim().split('\n');
  const swdirLines = swdirText.trim().split('\n');
  if (specLines.length < 3 || swdirLines.length < 3) return [];

  // Parse frequency bins from header row (line 1, the units/freq line)
  // Format varies; frequencies are in parentheses or are the header values
  const freqHeader = specLines[0].replace(/#/g, '').trim().split(/\s+/);
  const freqs = [];
  // Try extracting from parenthesized values in row 1
  const unitLine = specLines[1];
  const freqMatches = unitLine.match(/\(([^)]+)\)/g);
  if (freqMatches) {
    freqMatches.forEach(m => {
      const f = parseFloat(m.replace(/[()]/g, ''));
      if (!isNaN(f) && f > 0 && f < 1) freqs.push(f);
    });
  }

  const specRow = specLines[2].split(/\s+/);
  const swdirRow = swdirLines[2].split(/\s+/);

  const densities = specRow.slice(5).map(v => safeFloat(v));
  const directions = swdirRow.slice(5).map(v => safeFloat(v));

  const entries = [];
  const len = Math.min(freqs.length, densities.length, directions.length);
  for (let i = 0; i < len; i++) {
    if (densities[i] != null && directions[i] != null && freqs[i] > 0) {
      entries.push({
        freq: freqs[i],
        period_s: Math.round(10 / freqs[i]) / 10,
        energy: densities[i],
        direction_deg: directions[i],
      });
    }
  }
  return entries;
}

// =========================================================================
// Open-Meteo Marine Forecast
// =========================================================================
async function loadForecast(station) {
  try {
    const url = `https://marine-api.open-meteo.com/v1/marine?latitude=${station.lat}&longitude=${station.lon}&hourly=wave_height,wave_direction,wave_period,swell_wave_height,swell_wave_direction,swell_wave_period,wind_wave_height,wind_wave_direction,wind_wave_period&timezone=auto`;
    const data = await fetchJSON(url);
    const hourly = data.hourly;
    if (!hourly || !hourly.time) throw new Error('No hourly data');

    const hours = hourly.time.map((t, i) => ({
      time: t,
      waveHeight: hourly.wave_height?.[i],
      waveDir: hourly.wave_direction?.[i],
      wavePeriod: hourly.wave_period?.[i],
      swellHeight: hourly.swell_wave_height?.[i],
      swellDir: hourly.swell_wave_direction?.[i],
      swellPeriod: hourly.swell_wave_period?.[i],
      windWaveHeight: hourly.wind_wave_height?.[i],
      windWaveDir: hourly.wind_wave_direction?.[i],
      windWavePeriod: hourly.wind_wave_period?.[i],
    }));

    drawForecastTimeline(hours);
    renderHourlyTable(hours);
    return true;
  } catch (e) {
    console.warn('Forecast error:', e);
    drawForecastTimeline([]);
    $('hourly-table').innerHTML = '<p class="error-msg">Forecast unavailable</p>';
    return false;
  }
}

// =========================================================================
// CO-OPS Tides (nearest station)
// =========================================================================
async function loadTides(station) {
  const now = new Date();
  const begin = formatDateCOOPS(now);
  const end = formatDateCOOPS(new Date(now.getTime() + 72 * 3600000));

  // Try a few nearby CO-OPS stations ‚Äî use the API predictions endpoint
  // We'll search by coordinates using the metadata API
  let tideStation = null;
  try {
    const metaUrl = `https://api.tidesandcurrents.noaa.gov/mdapi/prod/webapi/stations.json?type=tidepredictions&units=english`;
    const meta = await fetchJSON(metaUrl);
    if (meta.stations) {
      // Find nearest
      let minDist = Infinity;
      meta.stations.forEach(s => {
        const d = Math.hypot(s.lat - station.lat, s.lng - station.lon);
        if (d < minDist) { minDist = d; tideStation = s; }
      });
    }
  } catch (e) {
    console.warn('Tide station lookup error:', e);
  }

  const stationId = tideStation ? tideStation.id : '8510719';
  const stationName = tideStation ? tideStation.name : 'Unknown';
  $('tide-station-name').textContent = stationName;
  $('tide-source').textContent = `CO-OPS ${stationId}`;

  const url = `https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?begin_date=${begin}&end_date=${end}&station=${stationId}&product=predictions&datum=MLLW&units=english&time_zone=lst_ldt&interval=6&format=json`;
  try {
    const data = await fetchJSON(url);
    drawTides(data.predictions || []);
  } catch (e) {
    console.warn('Tide data error:', e);
    drawTides([]);
  }
}

function formatDateCOOPS(d) {
  return `${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}`;
}

// =========================================================================
// NWS Wind
// =========================================================================
async function loadWind(station) {
  try {
    const ptResp = await fetchJSON(`https://api.weather.gov/points/${station.lat.toFixed(4)},${station.lon.toFixed(4)}`);
    const fUrl = ptResp.properties?.forecastHourly;
    if (!fUrl) throw new Error('No forecast URL');
    const fResp = await fetch(fUrl, { headers: { 'User-Agent': 'SurfCheck/1.0' } });
    const fData = await fResp.json();
    const periods = fData.properties?.periods;
    if (periods && periods.length) {
      const p = periods[0];
      const spd = p.windSpeed ? parseInt(p.windSpeed) : null;
      $('wind-val').innerHTML = spd != null ? `${spd} <span class="unit">mph</span>` : 'N/A';
      const gust = p.windGust ? ` ¬∑ Gust ${p.windGust}` : '';
      $('wind-detail').textContent = `${p.windDirection || ''}${gust}`;
      return true;
    }
  } catch (e) {
    console.warn('NWS wind error:', e);
    // Fallback: show buoy wind if available
    $('wind-val').textContent = 'N/A';
    $('wind-detail').textContent = 'NWS unavailable (offshore?)';
    return false;
  }
}

// =========================================================================
// Rendering
// =========================================================================
function renderSwell(stdmet) {
  if (!stdmet) { $('swell-val').textContent = 'N/A'; return; }
  const htFt = mToFt(stdmet.waveHeight_m);
  if (htFt != null) {
    $('swell-val').innerHTML = `${htFt.toFixed(1)} <span class="unit">ft</span>`;
  } else {
    $('swell-val').textContent = 'N/A';
  }
  const parts = [];
  if (stdmet.dominantPeriod_s) parts.push(`${stdmet.dominantPeriod_s}s`);
  if (stdmet.meanDirection_deg != null) parts.push(`${degToCompass(stdmet.meanDirection_deg)} (${Math.round(stdmet.meanDirection_deg)}¬∞)`);
  $('swell-detail').textContent = parts.join(' ¬∑ ');
}

function renderTemp(stdmet) {
  if (!stdmet || stdmet.waterTemp_C == null) { $('temp-val').textContent = 'N/A'; return; }
  const f = cToF(stdmet.waterTemp_C);
  $('temp-val').innerHTML = `${f.toFixed(0)}¬∞ <span class="unit">F</span>`;
  $('temp-detail').textContent = `${stdmet.waterTemp_C.toFixed(1)}¬∞C`;
}

function renderDaylight(lat, lon) {
  const sun = calcSun(lat, lon, new Date());
  $('daylight-val').textContent = sun.hours;
  $('daylight-detail').textContent = `‚Üë ${sun.rise}  ‚Üì ${sun.set}`;
}

function calcSun(lat, lon, date) {
  const rad = Math.PI / 180;
  const dayOfYear = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 86400000);
  const decl = -23.45 * Math.cos(rad * 360 / 365 * (dayOfYear + 10));
  const cosHA = (Math.sin(-0.833 * rad) - Math.sin(lat * rad) * Math.sin(decl * rad))
    / (Math.cos(lat * rad) * Math.cos(decl * rad));
  if (Math.abs(cosHA) > 1) return { rise: '--:--', set: '--:--', hours: 'Polar' };
  const ha = Math.acos(cosHA) / rad;
  const B = rad * 360 / 365 * (dayOfYear - 81);
  const eot = 9.87 * Math.sin(2 * B) - 7.53 * Math.cos(B) - 1.5 * Math.sin(B);
  const solarNoon = 720 - 4 * lon - eot;
  // Guess timezone offset from longitude (rough)
  const tzOffset = Math.round(lon / 15) * 60;
  const rise = solarNoon - ha * 4 + tzOffset;
  const set = solarNoon + ha * 4 + tzOffset;
  const fmt = m => {
    let h = Math.floor(m / 60); let min = Math.round(m % 60);
    if (min === 60) { h++; min = 0; }
    const ap = h >= 12 ? 'PM' : 'AM';
    h = h % 12 || 12;
    return `${h}:${pad2(min)} ${ap}`;
  };
  const dl = set - rise;
  return { rise: fmt(rise), set: fmt(set), hours: `${Math.floor(dl / 60)}h ${Math.round(dl % 60)}m` };
}

// =========================================================================
// Canvas: Tide Chart
// =========================================================================
function drawTides(predictions) {
  const canvas = $('tideCanvas');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 180 * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  const W = rect.width, H = 180;

  if (!predictions || !predictions.length) {
    ctx.fillStyle = '#999'; ctx.font = '13px "DM Mono"';
    ctx.fillText('No tide data available', 20, H / 2);
    return;
  }

  const vals = predictions.map(p => ({ t: new Date(p.t), v: parseFloat(p.v) }));
  const minV = Math.min(...vals.map(v => v.v));
  const maxV = Math.max(...vals.map(v => v.v));
  const range = maxV - minV || 1;
  const tMin = vals[0].t.getTime(), tMax = vals[vals.length - 1].t.getTime();
  const tRange = tMax - tMin || 1;

  const pad = { t: 25, b: 30, l: 38, r: 10 };
  const cW = W - pad.l - pad.r, cH = H - pad.t - pad.b;
  const xp = v => pad.l + (v.t.getTime() - tMin) / tRange * cW;
  const yp = v => pad.t + cH - (v.v - minV) / range * cH;

  // Day grid
  ctx.strokeStyle = '#e5e1db'; ctx.lineWidth = 1; ctx.setLineDash([4, 4]);
  const startDay = new Date(vals[0].t); startDay.setHours(0, 0, 0, 0);
  for (let d = new Date(startDay); d.getTime() <= tMax; d.setDate(d.getDate() + 1)) {
    const dx = pad.l + (d.getTime() - tMin) / tRange * cW;
    if (dx > pad.l && dx < W - pad.r) {
      ctx.beginPath(); ctx.moveTo(dx, pad.t); ctx.lineTo(dx, H - pad.b); ctx.stroke();
      ctx.fillStyle = '#999'; ctx.font = '10px "DM Mono"';
      ctx.fillText(d.toLocaleDateString('en', { weekday: 'short' }), dx + 3, H - pad.b + 14);
    }
  }
  ctx.setLineDash([]);

  // Y labels
  ctx.fillStyle = '#999'; ctx.font = '10px "DM Mono"'; ctx.textAlign = 'right';
  for (let v = Math.ceil(minV * 2) / 2; v <= maxV + 0.25; v += 0.5) {
    const yy = pad.t + cH - (v - minV) / range * cH;
    if (yy > pad.t && yy < H - pad.b) ctx.fillText(v.toFixed(1) + 'ft', pad.l - 5, yy + 3);
  }
  ctx.textAlign = 'left';

  // Line
  ctx.beginPath(); ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 2;
  vals.forEach((v, i) => i === 0 ? ctx.moveTo(xp(v), yp(v)) : ctx.lineTo(xp(v), yp(v)));
  ctx.stroke();

  // Fill
  ctx.lineTo(xp(vals[vals.length - 1]), H - pad.b);
  ctx.lineTo(xp(vals[0]), H - pad.b);
  ctx.closePath();
  ctx.fillStyle = 'rgba(37,99,235,0.06)'; ctx.fill();

  // Now line
  const now = Date.now();
  const nowX = pad.l + (now - tMin) / tRange * cW;
  if (nowX > pad.l && nowX < W - pad.r) {
    ctx.strokeStyle = '#dc2626'; ctx.lineWidth = 1.5; ctx.setLineDash([3, 3]);
    ctx.beginPath(); ctx.moveTo(nowX, pad.t); ctx.lineTo(nowX, H - pad.b); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#dc2626'; ctx.font = '9px "DM Mono"';
    ctx.fillText('now', nowX + 3, pad.t + 10);
  }
}

// =========================================================================
// Canvas: Compass Rose
// =========================================================================
function drawCompass(spectral) {
  const canvas = $('compassCanvas');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 300 * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  const W = rect.width, H = 300;
  const cx = W / 2, cy = H / 2, R = Math.min(W, H) / 2 - 30;

  // Concentric rings
  for (let i = 1; i <= 4; i++) {
    ctx.beginPath(); ctx.arc(cx, cy, R * i / 4, 0, Math.PI * 2);
    ctx.strokeStyle = '#e5e1db'; ctx.lineWidth = 0.5; ctx.stroke();
  }

  // Cardinals
  ctx.fillStyle = '#999'; ctx.font = '11px "DM Mono"'; ctx.textAlign = 'center';
  [{ l: 'N', a: -90 }, { l: 'E', a: 0 }, { l: 'S', a: 90 }, { l: 'W', a: 180 }].forEach(d => {
    const a = d.a * Math.PI / 180;
    ctx.fillText(d.l, cx + (R + 20) * Math.cos(a), cy + (R + 20) * Math.sin(a) + 4);
    ctx.beginPath(); ctx.moveTo(cx, cy);
    ctx.lineTo(cx + R * Math.cos(a), cy + R * Math.sin(a));
    ctx.strokeStyle = '#ddd'; ctx.lineWidth = 0.5; ctx.stroke();
  });

  if (!spectral || !spectral.length) {
    ctx.fillStyle = '#999'; ctx.font = '12px "DM Mono"';
    ctx.fillText('No spectral data', cx, cy);
    return;
  }

  const maxE = Math.max(...spectral.map(s => s.energy));

  spectral.forEach(s => {
    const angle = (s.direction_deg - 90) * Math.PI / 180;
    const r = (s.energy / maxE) * R * 0.9;
    const halfW = 3 * Math.PI / 180;

    ctx.beginPath(); ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, r, angle - halfW, angle + halfW);
    ctx.closePath();

    // Color by period (longer = bluer)
    const periodNorm = Math.min((s.period_s || 5) / 18, 1);
    const alpha = 0.3 + periodNorm * 0.5;
    ctx.fillStyle = `rgba(37,99,235,${alpha})`;
    ctx.fill();

    if (s.energy > maxE * 0.3 && s.period_s) {
      ctx.fillStyle = '#333'; ctx.font = '9px "DM Mono"';
      ctx.fillText(`${s.period_s}s`, cx + (r + 14) * Math.cos(angle), cy + (r + 14) * Math.sin(angle) + 3);
    }
  });
}

// =========================================================================
// Canvas: Forecast Timeline
// =========================================================================
function drawForecastTimeline(hours) {
  const canvas = $('forecastCanvas');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 200 * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  const W = rect.width, H = 200;

  if (!hours || !hours.length) {
    ctx.fillStyle = '#999'; ctx.font = '13px "DM Mono"';
    ctx.fillText('No forecast data available', 20, H / 2);
    return;
  }

  const pts = hours.filter(h => h.waveHeight != null).map(h => ({
    t: new Date(h.time), ht: h.waveHeight * 3.28084
  }));
  if (!pts.length) return;

  const pad = { t: 20, b: 35, l: 38, r: 10 };
  const cW = W - pad.l - pad.r, cH = H - pad.t - pad.b;
  const maxHt = Math.max(...pts.map(p => p.ht), 3);
  const tMin = pts[0].t.getTime(), tMax = pts[pts.length - 1].t.getTime();
  const tRange = tMax - tMin || 1;

  const xp = p => pad.l + (p.t.getTime() - tMin) / tRange * cW;
  const yp = p => pad.t + cH - (p.ht / maxHt) * cH;

  // Grid
  ctx.strokeStyle = '#e5e1db'; ctx.lineWidth = 0.5; ctx.setLineDash([4, 4]);
  for (let v = 1; v <= maxHt; v++) {
    const yy = pad.t + cH - (v / maxHt) * cH;
    ctx.beginPath(); ctx.moveTo(pad.l, yy); ctx.lineTo(W - pad.r, yy); ctx.stroke();
    ctx.fillStyle = '#999'; ctx.font = '10px "DM Mono"'; ctx.textAlign = 'right';
    ctx.fillText(v + 'ft', pad.l - 5, yy + 3);
  }
  ctx.setLineDash([]);
  ctx.textAlign = 'left';

  // Day labels
  const startDay = new Date(pts[0].t); startDay.setHours(0, 0, 0, 0);
  for (let d = new Date(startDay); d.getTime() <= tMax; d.setDate(d.getDate() + 1)) {
    const dx = pad.l + (d.getTime() - tMin) / tRange * cW;
    if (dx >= pad.l && dx <= W - pad.r) {
      ctx.strokeStyle = '#e5e1db'; ctx.setLineDash([4, 4]);
      ctx.beginPath(); ctx.moveTo(dx, pad.t); ctx.lineTo(dx, H - pad.b); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = '#999'; ctx.font = '9px "DM Mono"';
      ctx.fillText(d.toLocaleDateString('en', { month: 'short', day: 'numeric' }), dx + 2, H - pad.b + 12);
    }
  }

  // Area + line
  ctx.beginPath();
  pts.forEach((p, i) => i === 0 ? ctx.moveTo(xp(p), yp(p)) : ctx.lineTo(xp(p), yp(p)));
  ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 2; ctx.stroke();
  ctx.lineTo(xp(pts[pts.length - 1]), H - pad.b);
  ctx.lineTo(xp(pts[0]), H - pad.b);
  ctx.closePath();
  ctx.fillStyle = 'rgba(37,99,235,0.08)'; ctx.fill();

  // Swell overlay (if available)
  const swellPts = hours.filter(h => h.swellHeight != null).map(h => ({
    t: new Date(h.time), ht: h.swellHeight * 3.28084
  }));
  if (swellPts.length) {
    ctx.beginPath();
    swellPts.forEach((p, i) => i === 0 ? ctx.moveTo(xp(p), yp(p)) : ctx.lineTo(xp(p), yp(p)));
    ctx.strokeStyle = '#16a34a'; ctx.lineWidth = 1.5; ctx.setLineDash([5, 3]); ctx.stroke();
    ctx.setLineDash([]);
  }

  // Now line
  const now = Date.now();
  const nowX = pad.l + (now - tMin) / tRange * cW;
  if (nowX >= pad.l && nowX <= W - pad.r) {
    ctx.strokeStyle = '#dc2626'; ctx.lineWidth = 1.5; ctx.setLineDash([3, 3]);
    ctx.beginPath(); ctx.moveTo(nowX, pad.t); ctx.lineTo(nowX, H - pad.b); ctx.stroke();
    ctx.setLineDash([]);
  }

  // Legend
  ctx.font = '9px "DM Mono"'; ctx.setLineDash([]);
  ctx.fillStyle = '#2563eb'; ctx.fillText('‚Äî Total', W - 120, pad.t + 10);
  if (swellPts.length) {
    ctx.fillStyle = '#16a34a'; ctx.fillText('--- Swell', W - 120, pad.t + 22);
  }
}

// =========================================================================
// Hourly Forecast Table
// =========================================================================
function renderHourlyTable(hours) {
  if (!hours || !hours.length) {
    $('hourly-table').innerHTML = '<p class="error-msg">No forecast data</p>';
    return;
  }

  const now = Date.now();
  const upcoming = hours.filter(h => new Date(h.time).getTime() >= now - 3600000).slice(0, 48);

  let html = `<table class="forecast-table">
    <thead><tr><th>Time</th><th>Ht</th><th>Per</th><th>Dir</th><th>Swell</th></tr></thead><tbody>`;

  upcoming.forEach(h => {
    const t = new Date(h.time);
    const tStr = t.toLocaleString('en', { weekday: 'short', hour: 'numeric', hour12: true });
    const ht = h.waveHeight != null ? (h.waveHeight * 3.28084).toFixed(1) + 'ft' : '‚Äî';
    const per = h.wavePeriod != null ? h.wavePeriod.toFixed(0) + 's' : '‚Äî';
    const dir = h.waveDir != null ? degToCompass(h.waveDir) : '‚Äî';
    const sw = h.swellHeight != null ? (h.swellHeight * 3.28084).toFixed(1) + 'ft' : '‚Äî';
    html += `<tr><td>${tStr}</td><td>${ht}</td><td>${per}</td><td>${dir}</td><td>${sw}</td></tr>`;
  });

  html += '</tbody></table>';
  $('hourly-table').innerHTML = html;
}

// =========================================================================
// Init
// =========================================================================
async function init() {
  await loadStations();
  initMap();
  initSearch();
}

init();
</script>
</body>
</html>
