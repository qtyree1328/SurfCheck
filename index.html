<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<title>SurfCheck</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=DM+Mono:wght@300;400;500&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css">
<script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#f4f1ec;--card:#fff;--text:#1a1a1a;--muted:#777;--accent:#2563eb;
  --good:#16a34a;--ok:#ca8a04;--bad:#dc2626;--border:#e5e1db;
  --night:rgba(30,40,70,0.07);
}
html{font-size:16px}
body{font-family:'Libre Baskerville',Georgia,serif;background:var(--bg);color:var(--text);
  max-width:540px;margin:0 auto;padding:0;line-height:1.5}
.header{padding:16px 16px 0}
h1{font-size:1.6rem;letter-spacing:-0.5px}
.subtitle{font-size:0.8rem;color:var(--muted);font-style:italic;margin-bottom:4px}
#map{width:100%;height:300px;border-bottom:1px solid var(--border)}
.content{padding:0 16px 16px}
h2{font-size:0.85rem;font-weight:400;color:var(--muted);margin:14px 0 8px;
  text-transform:uppercase;letter-spacing:1.5px;font-family:'DM Mono',monospace}
.card{background:var(--card);border-radius:12px;padding:16px;margin-bottom:14px;
  border:1px solid var(--border);box-shadow:0 1px 3px rgba(0,0,0,0.04)}
.card h3{font-size:0.75rem;text-transform:uppercase;letter-spacing:1.2px;
  color:var(--muted);font-family:'DM Mono',monospace;margin-bottom:8px;font-weight:400}
.big-val{font-size:2rem;font-weight:700;line-height:1.1}
.unit{font-size:0.85rem;font-weight:400;color:var(--muted)}
.sub{font-size:0.8rem;color:var(--muted);margin-top:4px;font-family:'DM Mono',monospace}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:14px}
.grid4{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:10px}
.source{font-size:0.65rem;color:var(--muted);font-family:'DM Mono',monospace;margin-top:6px;opacity:0.7}
canvas{width:100%;border-radius:8px;background:#fff}
.forecast-table{width:100%;border-collapse:collapse;font-family:'DM Mono',monospace;font-size:0.7rem}
.forecast-table th{text-align:left;padding:6px 4px;border-bottom:2px solid var(--border);
  font-weight:500;color:var(--muted);text-transform:uppercase;letter-spacing:0.5px}
.forecast-table td{padding:5px 4px;border-bottom:1px solid var(--border)}
.forecast-table tr:hover{background:rgba(37,99,235,0.04)}
iframe{width:100%;border:none;border-radius:8px}
.loading{color:var(--muted);font-style:italic}
.timestamp{font-size:0.65rem;color:var(--muted);font-family:'DM Mono',monospace;text-align:center;margin:20px 0 10px}
#buoy-name{font-size:1.1rem;font-weight:700;margin:12px 0 2px}
#buoy-meta{font-size:0.75rem;color:var(--muted);font-family:'DM Mono',monospace;margin-bottom:4px}
.search-wrap{position:relative;margin:8px 16px}
#buoy-search{width:100%;padding:8px 12px;border:1px solid var(--border);border-radius:8px;
  font-family:'DM Mono',monospace;font-size:0.8rem;background:var(--card);outline:none}
#buoy-search:focus{border-color:var(--accent)}
#search-results{position:absolute;top:100%;left:0;right:0;background:var(--card);
  border:1px solid var(--border);border-radius:0 0 8px 8px;max-height:200px;overflow-y:auto;
  z-index:1000;display:none;box-shadow:0 4px 12px rgba(0,0,0,0.1)}
#search-results div{padding:8px 12px;cursor:pointer;font-family:'DM Mono',monospace;font-size:0.75rem;
  border-bottom:1px solid var(--border)}
#search-results div:hover{background:rgba(37,99,235,0.06)}
.error-msg{color:var(--bad);font-size:0.8rem;font-family:'DM Mono',monospace;padding:8px 0}
#buoy-warning{display:none;background:#fffdf5;border:1px solid #e5c07b;border-radius:10px;
  padding:12px 14px;margin-bottom:14px;font-family:'DM Mono',monospace;font-size:0.8rem;color:#92700c}

/* Hero summary */
.hero-summary{background:var(--card);border-radius:14px;padding:20px;margin-bottom:14px;
  border:1px solid var(--border);box-shadow:0 2px 8px rgba(0,0,0,0.04);text-align:center}
.hero-height{font-size:3.2rem;font-weight:700;line-height:1;letter-spacing:-1px;color:var(--text)}
.hero-detail{font-size:1rem;color:var(--muted);margin-top:4px;font-family:'DM Mono',monospace}
.hero-components{margin-top:10px;font-size:0.75rem;color:var(--muted);font-family:'DM Mono',monospace}

/* Stat pills */
.stat-strip{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:14px}
.stat-pill{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:10px 8px;text-align:center}
.stat-pill .stat-icon{font-size:1.1rem}
.stat-pill .stat-label{font-size:0.55rem;text-transform:uppercase;letter-spacing:1px;color:var(--muted);font-family:'DM Mono',monospace;margin:2px 0}
.stat-pill .stat-value{font-size:0.95rem;font-weight:700;line-height:1.1}
.stat-pill .stat-sub{font-size:0.6rem;color:var(--muted);font-family:'DM Mono',monospace;margin-top:1px}

/* Scrollable chart containers */
.chart-scroll{overflow-x:auto;-webkit-overflow-scrolling:touch;margin:0 -4px;padding:0 4px}
.chart-scroll canvas{min-width:700px;display:block}
</style>
</head>
<body>

<div class="header">
  <h1>SurfCheck</h1>
  <p class="subtitle">Click a buoy on the map or search below</p>
</div>

<div class="search-wrap">
  <input type="text" id="buoy-search" placeholder="Search buoys (e.g. Block Island, 44097)..." autocomplete="off">
  <div id="search-results"></div>
</div>

<div id="map"></div>

<div class="content">
  <div id="buoy-name">Select a buoy</div>
  <div id="buoy-meta"></div>
  <p id="status" class="sub loading"></p>
  <div id="buoy-warning">‚ö†Ô∏è Station inactive ‚Äî no recent buoy data available. Forecast &amp; wind still shown from model data.</div>

  <!-- Hero Summary -->
  <div class="hero-summary" id="hero-summary" style="display:none">
    <div class="hero-height" id="hero-height">‚Äî</div>
    <div class="hero-detail" id="hero-detail"></div>
    <div class="hero-components" id="hero-components"></div>
  </div>

  <!-- Stat Strip -->
  <div class="stat-strip">
    <div class="stat-pill">
      <div class="stat-icon">üí®</div>
      <div class="stat-label">Wind</div>
      <div class="stat-value" id="stat-wind">‚Äî</div>
      <div class="stat-sub" id="stat-wind-sub"></div>
    </div>
    <div class="stat-pill">
      <div class="stat-icon">üå°Ô∏è</div>
      <div class="stat-label">Water</div>
      <div class="stat-value" id="stat-temp">‚Äî</div>
      <div class="stat-sub" id="stat-temp-sub"></div>
    </div>
    <div class="stat-pill">
      <div class="stat-icon">üåä</div>
      <div class="stat-label">Tide</div>
      <div class="stat-value" id="stat-tide">‚Äî</div>
      <div class="stat-sub" id="stat-tide-sub"></div>
    </div>
    <div class="stat-pill">
      <div class="stat-icon">‚òÄÔ∏è</div>
      <div class="stat-label">Sun</div>
      <div class="stat-value" id="stat-sun">‚Äî</div>
      <div class="stat-sub" id="stat-sun-sub"></div>
    </div>
  </div>

  <!-- Surf Forecast Timeline (MAIN CHART) -->
  <div class="card">
    <h3>üìà Surf Forecast</h3>
    <div class="chart-scroll">
      <canvas id="forecastCanvas" height="220"></canvas>
    </div>
    <div class="source">Open-Meteo Marine API</div>
  </div>

  <!-- Tide Chart -->
  <div class="card">
    <h3>üåä Tides ‚Äî <span id="tide-station-name">Nearest Station</span></h3>
    <div class="chart-scroll">
      <canvas id="tideCanvas" height="200"></canvas>
    </div>
    <div class="source" id="tide-source">CO-OPS</div>
  </div>

  <!-- Swell Energy Spectrum -->
  <div class="card">
    <h3>üìä Wave Energy Spectrum</h3>
    <canvas id="spectrumCanvas" height="220"></canvas>
    <div class="source">NDBC <span class="buoy-id-ref"></span> spectral</div>
  </div>

  <!-- Compass Rose -->
  <div class="card">
    <h3>üß≠ Swell Direction ‚Äî Spectral Compass Rose</h3>
    <canvas id="compassCanvas" height="320"></canvas>
    <div class="sub">Swell energy by direction &amp; period</div>
    <div class="source">NDBC <span class="buoy-id-ref"></span> spectral</div>
  </div>

  <!-- Hourly Table -->
  <div class="card">
    <h3>üìã Hourly Forecast Detail</h3>
    <div id="hourly-table"></div>
    <div class="source">Open-Meteo Marine API</div>
  </div>

  <!-- Windy -->
  <div class="card">
    <h3>üó∫Ô∏è Wind Map</h3>
    <iframe id="windy-iframe" height="400" loading="lazy"></iframe>
    <div class="source">Windy.com ¬∑ ECMWF</div>
  </div>

  <div class="timestamp" id="footer-ts"></div>
</div>

<script>
// =========================================================================
// SurfCheck v2 ‚Äî HopeWaves-quality buoy dashboard
// =========================================================================

const CORS_PROXY = 'https://corsproxy.io/?';
const $ = id => document.getElementById(id);
const mToFt = m => m != null ? (m * 3.28084) : null;
const cToF = c => c != null ? (c * 9/5 + 32) : null;
const degToCompass = d => {
  if (d == null) return '?';
  const dirs = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'];
  return dirs[Math.round(d / 22.5) % 16];
};
const pad2 = n => String(n).padStart(2, '0');

const MISSING_FLOATS = new Set([99, 99.0, 999, 999.0, 9999, 9999.0, 9.9, 9.99]);
function safeFloat(val) {
  if (val == null || val === '' || val === 'MM') return null;
  const f = parseFloat(val);
  if (isNaN(f)) return null;
  if (MISSING_FLOATS.has(f)) return null;
  return f;
}
function safeWaveHeight(val) {
  const f = safeFloat(val);
  if (f != null && f > 8.0) return null;
  return f;
}

let stations = [];
let currentBuoy = null;
let map = null;
let _sunCache = {};

// =========================================================================
// Buoy type filtering ‚Äî only show wave-reporting buoys
// =========================================================================
function isWaveBuoy(station) {
  const t = (station.type || '').toLowerCase();
  // Filter out C-MAN, ships, fixed platforms, DART, TAO
  if (t.startsWith('c-man')) return false;
  if (t.includes('ship')) return false;
  if (t.includes('dart')) return false;
  if (t.includes('fixed')) return false;
  if (t.includes('tao') || t.includes('atlas')) return false;
  // Keep anything with "buoy" in type
  if (t.includes('buoy')) return true;
  // Keep 3m/discus/weather buoys
  if (t.includes('3-meter') || t.includes('discus') || t.includes('weather')) return true;
  // Keep if type is empty but has a numeric ID (often buoys)
  if (!t && /^\d{5}$/.test(station.id)) return true;
  return false;
}

// =========================================================================
// Sunrise / sunset (astronomical calculation)
// =========================================================================
function calcSunTimes(lat, lon, date) {
  const key = `${lat.toFixed(2)}_${lon.toFixed(2)}_${date.toDateString()}`;
  if (_sunCache[key]) return _sunCache[key];

  const rad = Math.PI / 180;
  const dayOfYear = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 86400000);
  const decl = -23.45 * Math.cos(rad * 360 / 365 * (dayOfYear + 10));
  const cosHA = (Math.sin(-0.833 * rad) - Math.sin(lat * rad) * Math.sin(decl * rad))
    / (Math.cos(lat * rad) * Math.cos(decl * rad));
  if (Math.abs(cosHA) > 1) {
    const r = { riseMin: 360, setMin: 1080, rise: '--:--', set: '--:--', hours: 'Polar' };
    _sunCache[key] = r; return r;
  }
  const ha = Math.acos(cosHA) / rad;
  const B = rad * 360 / 365 * (dayOfYear - 81);
  const eot = 9.87 * Math.sin(2 * B) - 7.53 * Math.cos(B) - 1.5 * Math.sin(B);
  const solarNoon = 720 - 4 * lon - eot;
  const tzOffset = Math.round(lon / 15) * 60;
  const riseMin = solarNoon - ha * 4 + tzOffset;
  const setMin = solarNoon + ha * 4 + tzOffset;
  const fmt = m => {
    let h = Math.floor(m / 60); let min = Math.round(m % 60);
    if (min === 60) { h++; min = 0; }
    const ap = h >= 12 ? 'PM' : 'AM';
    h = h % 12 || 12;
    return `${h}:${pad2(min)} ${ap}`;
  };
  const dl = setMin - riseMin;
  const r = { riseMin, setMin, rise: fmt(riseMin), set: fmt(setMin), hours: `${Math.floor(dl / 60)}h ${Math.round(dl % 60)}m` };
  _sunCache[key] = r;
  return r;
}

// =========================================================================
// Fetch helpers
// =========================================================================
async function fetchText(url, useCors = false) {
  const target = useCors ? CORS_PROXY + encodeURIComponent(url) : url;
  const resp = await fetch(target);
  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
  return await resp.text();
}
async function fetchNDBC(buoyId, ext) {
  const url = `https://www.ndbc.noaa.gov/data/realtime2/${buoyId}${ext}`;
  try { return await fetchText(url, false); }
  catch { return await fetchText(url, true); }
}
async function fetchJSON(url) {
  const resp = await fetch(url);
  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
  return await resp.json();
}

// =========================================================================
// Station loading & map
// =========================================================================
async function loadStations() {
  const all = await fetchJSON('data/stations.json');
  stations = all.filter(isWaveBuoy);
  return stations;
}

function initMap() {
  map = new maplibregl.Map({
    container: 'map',
    style: {
      version: 8,
      sources: { osm: { type: 'raster', tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'], tileSize: 256, attribution: '&copy; OpenStreetMap' } },
      layers: [{ id: 'osm', type: 'raster', source: 'osm' }],
      glyphs: 'https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf'
    },
    center: [-71.1, 41.0], zoom: 4, maxZoom: 14
  });
  map.addControl(new maplibregl.NavigationControl(), 'top-right');

  map.on('load', () => {
    const geojson = {
      type: 'FeatureCollection',
      features: stations.map(s => ({
        type: 'Feature',
        geometry: { type: 'Point', coordinates: [s.lon, s.lat] },
        properties: { id: s.id, name: s.name, type: s.type }
      }))
    };
    map.addSource('buoys', { type: 'geojson', data: geojson });
    map.addLayer({
      id: 'buoy-circles', type: 'circle', source: 'buoys',
      paint: {
        'circle-radius': ['interpolate', ['linear'], ['zoom'], 2, 2.5, 6, 4, 10, 7],
        'circle-color': '#2563eb', 'circle-stroke-width': 1.5, 'circle-stroke-color': '#fff', 'circle-opacity': 0.85
      }
    });
    map.addLayer({
      id: 'buoy-selected', type: 'circle', source: 'buoys',
      filter: ['==', ['get', 'id'], ''],
      paint: {
        'circle-radius': ['interpolate', ['linear'], ['zoom'], 2, 5, 6, 8, 10, 12],
        'circle-color': '#dc2626', 'circle-stroke-width': 2.5, 'circle-stroke-color': '#fff'
      }
    });
    map.on('click', 'buoy-circles', e => selectBuoy(e.features[0].properties.id));
    map.on('mouseenter', 'buoy-circles', () => map.getCanvas().style.cursor = 'pointer');
    map.on('mouseleave', 'buoy-circles', () => map.getCanvas().style.cursor = '');
    const popup = new maplibregl.Popup({ closeButton: false, closeOnClick: false, offset: 10 });
    map.on('mouseenter', 'buoy-circles', e => {
      const p = e.features[0].properties;
      popup.setLngLat(e.lngLat).setHTML(`<strong>${p.id}</strong><br>${p.name}<br><em>${p.type}</em>`).addTo(map);
    });
    map.on('mouseleave', 'buoy-circles', () => popup.remove());

    const hashBuoy = location.hash.replace('#', '');
    selectBuoy(hashBuoy || '44097');
  });
}

// =========================================================================
// Search
// =========================================================================
function initSearch() {
  const input = $('buoy-search'), results = $('search-results');
  input.addEventListener('input', () => {
    const q = input.value.trim().toLowerCase();
    if (q.length < 2) { results.style.display = 'none'; return; }
    const matches = stations.filter(s => s.id.toLowerCase().includes(q) || s.name.toLowerCase().includes(q)).slice(0, 15);
    if (!matches.length) { results.style.display = 'none'; return; }
    results.innerHTML = matches.map(s =>
      `<div data-id="${s.id}"><strong>${s.id}</strong> ‚Äî ${s.name} <em style="color:#999">${s.type}</em></div>`
    ).join('');
    results.style.display = 'block';
  });
  results.addEventListener('click', e => {
    const div = e.target.closest('[data-id]');
    if (div) { selectBuoy(div.dataset.id); input.value = ''; results.style.display = 'none'; }
  });
  input.addEventListener('blur', () => setTimeout(() => results.style.display = 'none', 200));
}

// =========================================================================
// Select Buoy
// =========================================================================
function selectBuoy(buoyId) {
  const station = stations.find(s => s.id === buoyId);
  if (!station) { $('buoy-name').textContent = `Buoy ${buoyId} not found`; return; }
  currentBuoy = station;
  location.hash = buoyId;
  $('buoy-name').textContent = station.name;
  $('buoy-meta').textContent = `${station.id} ¬∑ ${station.type} ¬∑ ${station.lat.toFixed(3)}¬∞N, ${Math.abs(station.lon).toFixed(3)}¬∞W`;
  document.querySelectorAll('.buoy-id-ref').forEach(el => el.textContent = station.id);
  $('status').textContent = 'Loading data‚Ä¶';
  $('status').classList.add('loading');
  if (map && map.getLayer('buoy-selected')) {
    map.setFilter('buoy-selected', ['==', ['get', 'id'], buoyId]);
    map.flyTo({ center: [station.lon, station.lat], zoom: 8, duration: 1500 });
  }
  $('windy-iframe').src = `https://embed.windy.com/embed.html?type=map&location=coordinates&metricRain=default&metricTemp=default&metricWind=default&zoom=8&overlay=wind&product=ecmwf&level=surface&lat=${station.lat}&lon=${station.lon}`;
  loadAllData(station);
}

// =========================================================================
// Data Loading
// =========================================================================
async function loadAllData(station) {
  $('hero-summary').style.display = 'none';
  $('buoy-warning').style.display = 'none';
  _sunCache = {};

  // Daylight stat
  const sun = calcSunTimes(station.lat, station.lon, new Date());
  $('stat-sun').textContent = sun.hours;
  $('stat-sun-sub').textContent = `‚Üë${sun.rise}`;

  const results = await Promise.allSettled([
    loadBuoyData(station),
    loadForecast(station),
    loadTides(station),
    loadWind(station),
  ]);

  const labels = ['Buoy','Forecast','Tides','Wind'];
  $('status').textContent = results.map((r, i) =>
    `${labels[i]} ${r.status === 'fulfilled' && r.value ? '‚úì' : '‚úó'}`
  ).join(' ¬∑ ');
  $('status').classList.remove('loading');
  $('footer-ts').textContent = `Last loaded: ${new Date().toLocaleString()}`;
}

// =========================================================================
// NDBC Buoy Data
// =========================================================================
async function loadBuoyData(station) {
  let buoyActive = false;
  try {
    const stdmetText = await fetchNDBC(station.id, '.txt');
    const stdmet = parseStdmet(stdmetText);
    if (stdmet && (stdmet.waveHeight_m != null || stdmet.waterTemp_C != null)) buoyActive = true;
    renderHero(stdmet);
    renderStatTemp(stdmet);
  } catch (e) { console.warn('Buoy stdmet error:', e); }

  if (!buoyActive) {
    $('buoy-warning').style.display = 'block';
    $('hero-summary').style.display = 'block';
    $('hero-height').textContent = '‚Äî';
    $('hero-detail').textContent = 'Station inactive';
    $('hero-components').textContent = '';
  }

  // Spectral data
  try {
    const [specText, swdirText] = await Promise.all([
      fetchNDBC(station.id, '.data_spec'),
      fetchNDBC(station.id, '.swdir'),
    ]);
    const spectral = parseSpectral(specText, swdirText);
    drawCompass(spectral);
    drawSpectrum(spectral);
  } catch (e) {
    console.warn('Spectral error:', e);
    drawCompass([]);
    drawSpectrum([]);
  }
  return buoyActive;
}

function parseStdmet(text) {
  const lines = text.trim().split('\n');
  if (lines.length < 3) return null;
  const row = lines[2].split(/\s+/);
  if (row.length < 13) return null;
  return {
    time: `${row[0]}-${row[1]}-${row[2]}T${row[3]}:${row[4]}Z`,
    waveHeight_m: safeWaveHeight(row[8]),
    dominantPeriod_s: safeFloat(row[9]),
    avgPeriod_s: safeFloat(row[10]),
    meanDirection_deg: safeFloat(row[11]),
    pressure_hPa: safeFloat(row[12]),
    airTemp_C: safeFloat(row[13]),
    waterTemp_C: row.length > 14 ? safeFloat(row[14]) : null,
    windDir_deg: safeFloat(row[5]),
    windSpeed_mps: safeFloat(row[6]),
    gust_mps: safeFloat(row[7]),
  };
}

function parseSpectral(specText, swdirText) {
  const specLines = specText.trim().split('\n');
  const swdirLines = swdirText.trim().split('\n');
  if (specLines.length < 2 || swdirLines.length < 2) return [];

  // Most recent observation (line 1, after header)
  const specLine = specLines[1];
  const swdirLine = swdirLines[1];

  // Extract freq/energy pairs: "energy (freq) energy (freq) ..."
  // After the first 5 fields (YY MM DD hh mm) and sep_freq
  const freqs = [], densities = [];
  const pairRegex = /([\d.]+)\s+\(([\d.]+)\)/g;
  let m;
  while ((m = pairRegex.exec(specLine)) !== null) {
    const energy = safeFloat(m[1]);
    const freq = parseFloat(m[2]);
    if (!isNaN(freq) && freq > 0 && freq < 1) {
      freqs.push(freq);
      densities.push(energy);
    }
  }

  // swdir has same format: "direction (freq) direction (freq) ..."
  const directions = [];
  const dirRegex = /([\d.]+)\s+\(([\d.]+)\)/g;
  while ((m = dirRegex.exec(swdirLine)) !== null) {
    directions.push(safeFloat(m[1]));
  }

  const entries = [];
  const len = Math.min(freqs.length, densities.length, directions.length);
  for (let i = 0; i < len; i++) {
    if (densities[i] != null && directions[i] != null && freqs[i] > 0) {
      entries.push({
        freq: freqs[i],
        period_s: Math.round(10 / freqs[i]) / 10,
        energy: densities[i],
        direction_deg: directions[i],
      });
    }
  }
  return entries;
}

// =========================================================================
// Hero Summary
// =========================================================================
function renderHero(stdmet) {
  const el = $('hero-summary');
  el.style.display = 'block';
  if (!stdmet || stdmet.waveHeight_m == null) {
    $('hero-height').textContent = '‚Äî';
    $('hero-detail').textContent = 'No current data';
    return;
  }
  const htFt = mToFt(stdmet.waveHeight_m);
  $('hero-height').textContent = `${htFt.toFixed(1)} ft`;
  const parts = [];
  if (stdmet.dominantPeriod_s) parts.push(`@ ${stdmet.dominantPeriod_s}s`);
  if (stdmet.meanDirection_deg != null) parts.push(degToCompass(stdmet.meanDirection_deg));
  $('hero-detail').textContent = parts.join(' ');

  // Height descriptor
  let desc = '';
  if (htFt < 1) desc = 'Flat';
  else if (htFt < 2) desc = 'Ankle‚ÄìKnee';
  else if (htFt < 3) desc = 'Knee‚ÄìWaist';
  else if (htFt < 4) desc = 'Waist‚ÄìChest';
  else if (htFt < 5) desc = 'Chest‚ÄìHead';
  else if (htFt < 7) desc = 'Overhead';
  else desc = 'Double overhead+';
  $('hero-components').textContent = desc;
}

function renderStatTemp(stdmet) {
  if (!stdmet || stdmet.waterTemp_C == null) {
    $('stat-temp').textContent = '‚Äî';
    $('stat-temp-sub').textContent = '';
    return;
  }
  const f = cToF(stdmet.waterTemp_C);
  $('stat-temp').textContent = `${f.toFixed(0)}¬∞F`;
  $('stat-temp-sub').textContent = `${stdmet.waterTemp_C.toFixed(1)}¬∞C`;
}

// =========================================================================
// Open-Meteo Marine Forecast
// =========================================================================
async function loadForecast(station) {
  try {
    const url = `https://marine-api.open-meteo.com/v1/marine?latitude=${station.lat}&longitude=${station.lon}&hourly=wave_height,wave_direction,wave_period,swell_wave_height,swell_wave_direction,swell_wave_period,wind_wave_height,wind_wave_direction,wind_wave_period&timezone=auto`;
    const data = await fetchJSON(url);
    const hourly = data.hourly;
    if (!hourly || !hourly.time) throw new Error('No hourly data');
    const hours = hourly.time.map((t, i) => ({
      time: t,
      waveHeight: hourly.wave_height?.[i],
      waveDir: hourly.wave_direction?.[i],
      wavePeriod: hourly.wave_period?.[i],
      swellHeight: hourly.swell_wave_height?.[i],
      swellDir: hourly.swell_wave_direction?.[i],
      swellPeriod: hourly.swell_wave_period?.[i],
      windWaveHeight: hourly.wind_wave_height?.[i],
      windWaveDir: hourly.wind_wave_direction?.[i],
      windWavePeriod: hourly.wind_wave_period?.[i],
    }));
    drawForecastTimeline(hours, station);
    renderHourlyTable(hours);
    return true;
  } catch (e) {
    console.warn('Forecast error:', e);
    drawForecastTimeline([], station);
    $('hourly-table').innerHTML = '<p class="error-msg">Forecast unavailable</p>';
    return false;
  }
}

// =========================================================================
// CO-OPS Tides
// =========================================================================
async function loadTides(station) {
  const now = new Date();
  const begin = formatDateCOOPS(now);
  const end = formatDateCOOPS(new Date(now.getTime() + 72 * 3600000));

  let tideStation = null;
  try {
    const metaUrl = 'https://api.tidesandcurrents.noaa.gov/mdapi/prod/webapi/stations.json?type=tidepredictions&units=english';
    const meta = await fetchJSON(metaUrl);
    if (meta.stations) {
      let minDist = Infinity;
      meta.stations.forEach(s => {
        const d = Math.hypot(s.lat - station.lat, s.lng - station.lon);
        if (d < minDist) { minDist = d; tideStation = s; }
      });
    }
  } catch (e) { console.warn('Tide station lookup error:', e); }

  const stationId = tideStation ? tideStation.id : '8510719';
  const stationName = tideStation ? tideStation.name : 'Unknown';
  $('tide-station-name').textContent = stationName;
  $('tide-source').textContent = `CO-OPS ${stationId}`;

  // Fetch predictions + hi/lo
  const predUrl = `https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?begin_date=${begin}&end_date=${end}&station=${stationId}&product=predictions&datum=MLLW&units=english&time_zone=lst_ldt&interval=6&format=json`;
  const hiloUrl = `https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?begin_date=${begin}&end_date=${end}&station=${stationId}&product=predictions&datum=MLLW&units=english&time_zone=lst_ldt&interval=hilo&format=json`;

  try {
    const [predData, hiloData] = await Promise.all([fetchJSON(predUrl), fetchJSON(hiloUrl).catch(() => ({ predictions: [] }))]);
    const predictions = predData.predictions || [];
    const hilo = hiloData.predictions || [];
    drawTides(predictions, hilo, station);

    // Current tide stat
    if (hilo.length) {
      const nowMs = Date.now();
      let next = hilo.find(h => new Date(h.t).getTime() > nowMs);
      if (next) {
        const type = next.type === 'H' ? 'High' : 'Low';
        const t = new Date(next.t);
        $('stat-tide').textContent = `${parseFloat(next.v).toFixed(1)}ft`;
        $('stat-tide-sub').textContent = `${type} ${t.toLocaleTimeString('en', { hour: 'numeric', minute: '2-digit' })}`;
      }
    }
    return true;
  } catch (e) {
    console.warn('Tide data error:', e);
    drawTides([], [], station);
    return false;
  }
}

function formatDateCOOPS(d) {
  return `${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}`;
}

// =========================================================================
// NWS Wind
// =========================================================================
async function loadWind(station) {
  try {
    const ptResp = await fetchJSON(`https://api.weather.gov/points/${station.lat.toFixed(4)},${station.lon.toFixed(4)}`);
    const fUrl = ptResp.properties?.forecastHourly;
    if (!fUrl) throw new Error('No forecast URL');
    const fResp = await fetch(fUrl, { headers: { 'User-Agent': 'SurfCheck/1.0' } });
    const fData = await fResp.json();
    const periods = fData.properties?.periods;
    if (periods && periods.length) {
      const p = periods[0];
      const spd = p.windSpeed ? parseInt(p.windSpeed) : null;
      $('stat-wind').textContent = spd != null ? `${spd}mph` : 'N/A';
      const gust = p.windGust ? `G${parseInt(p.windGust)}` : '';
      $('stat-wind-sub').textContent = `${p.windDirection || ''} ${gust}`.trim();
      return true;
    }
  } catch (e) {
    console.warn('NWS wind error:', e);
    $('stat-wind').textContent = 'N/A';
    $('stat-wind-sub').textContent = 'offshore';
    return false;
  }
}

// =========================================================================
// Canvas: Night shading helper
// =========================================================================
function drawNightBands(ctx, lat, lon, tMin, tMax, tRange, padL, padR, padT, padB, W, H) {
  const cW = W - padL - padR;
  const startDate = new Date(tMin);
  startDate.setHours(0, 0, 0, 0);
  ctx.fillStyle = 'rgba(30,40,70,0.06)';

  for (let d = new Date(startDate.getTime() - 86400000); d.getTime() <= tMax + 86400000; d.setDate(d.getDate() + 1)) {
    const sun = calcSunTimes(lat, lon, d);
    // Night before sunrise
    const dayStart = d.getTime();
    const riseMs = dayStart + sun.riseMin * 60000;
    const setMs = dayStart + sun.setMin * 60000;

    // Pre-dawn: midnight to sunrise
    const preDawnX1 = padL + (dayStart - tMin) / tRange * cW;
    const preDawnX2 = padL + (riseMs - tMin) / tRange * cW;
    const x1 = Math.max(padL, Math.min(W - padR, preDawnX1));
    const x2 = Math.max(padL, Math.min(W - padR, preDawnX2));
    if (x2 > x1) ctx.fillRect(x1, padT, x2 - x1, H - padT - padB);

    // Post-dusk: sunset to midnight
    const postDuskX1 = padL + (setMs - tMin) / tRange * cW;
    const postDuskX2 = padL + (dayStart + 86400000 - tMin) / tRange * cW;
    const x3 = Math.max(padL, Math.min(W - padR, postDuskX1));
    const x4 = Math.max(padL, Math.min(W - padR, postDuskX2));
    if (x4 > x3) ctx.fillRect(x3, padT, x4 - x3, H - padT - padB);
  }
}

// =========================================================================
// Canvas: Surf Forecast Timeline (MAIN CHART)
// =========================================================================
function drawForecastTimeline(hours, station) {
  const canvas = $('forecastCanvas');
  const dpr = window.devicePixelRatio || 1;
  const W = Math.max(700, canvas.parentElement.getBoundingClientRect().width);
  const H = 220;
  canvas.style.width = W + 'px';
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  if (!hours || !hours.length) {
    ctx.fillStyle = '#999'; ctx.font = '13px "DM Mono"';
    ctx.fillText('No forecast data available', 20, H / 2);
    return;
  }

  const pts = hours.filter(h => h.waveHeight != null).map(h => ({
    t: new Date(h.time), ht: h.waveHeight * 3.28084, dir: h.waveDir
  }));
  if (!pts.length) return;

  const pad = { t: 20, b: 40, l: 44, r: 14 };
  const cW = W - pad.l - pad.r, cH = H - pad.t - pad.b;
  const maxHt = Math.max(...pts.map(p => p.ht), 6);
  const tMin = pts[0].t.getTime(), tMax = pts[pts.length - 1].t.getTime();
  const tRange = tMax - tMin || 1;

  const xp = p => pad.l + (p.t.getTime() - tMin) / tRange * cW;
  const yp = ht => pad.t + cH - (ht / maxHt) * cH;

  // Night shading
  if (station) drawNightBands(ctx, station.lat, station.lon, tMin, tMax, tRange, pad.l, pad.r, pad.t, pad.b, W, H);

  // Height reference lines
  const refs = [
    { ft: 2, label: 'Knee' }, { ft: 3, label: 'Waist' },
    { ft: 4, label: 'Chest' }, { ft: 5, label: 'Head' }, { ft: 6, label: 'OH' }
  ];
  refs.forEach(r => {
    if (r.ft > maxHt) return;
    const yy = yp(r.ft);
    ctx.strokeStyle = 'rgba(37,99,235,0.15)'; ctx.lineWidth = 1; ctx.setLineDash([6, 4]);
    ctx.beginPath(); ctx.moveTo(pad.l, yy); ctx.lineTo(W - pad.r, yy); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(37,99,235,0.4)'; ctx.font = '9px "DM Mono"'; ctx.textAlign = 'right';
    ctx.fillText(r.label, pad.l - 4, yy + 3);
  });

  // Y-axis ft labels
  ctx.textAlign = 'right'; ctx.fillStyle = '#999'; ctx.font = '10px "DM Mono"';
  for (let v = 0; v <= maxHt; v += 1) {
    const yy = yp(v);
    if (yy > pad.t && yy < H - pad.b) {
      ctx.fillText(v + 'ft', pad.l - 14, yy + 3);
    }
  }
  ctx.textAlign = 'left';

  // Day grid + labels
  const startDay = new Date(pts[0].t); startDay.setHours(0, 0, 0, 0);
  for (let d = new Date(startDay); d.getTime() <= tMax; d.setDate(d.getDate() + 1)) {
    const dx = pad.l + (d.getTime() - tMin) / tRange * cW;
    if (dx >= pad.l && dx <= W - pad.r) {
      ctx.strokeStyle = '#d5d1cb'; ctx.lineWidth = 0.5; ctx.setLineDash([]);
      ctx.beginPath(); ctx.moveTo(dx, pad.t); ctx.lineTo(dx, H - pad.b); ctx.stroke();
      ctx.fillStyle = '#666'; ctx.font = '10px "DM Mono"';
      ctx.fillText(d.toLocaleDateString('en', { weekday: 'short', month: 'short', day: 'numeric' }), dx + 4, H - pad.b + 14);
    }
  }

  // Area fill (gradient by height)
  ctx.beginPath();
  pts.forEach((p, i) => i === 0 ? ctx.moveTo(xp(p), yp(p.ht)) : ctx.lineTo(xp(p), yp(p.ht)));
  ctx.lineTo(xp(pts[pts.length - 1]), H - pad.b);
  ctx.lineTo(xp(pts[0]), H - pad.b);
  ctx.closePath();
  const grad = ctx.createLinearGradient(0, pad.t, 0, H - pad.b);
  grad.addColorStop(0, 'rgba(37,99,235,0.25)');
  grad.addColorStop(1, 'rgba(37,99,235,0.02)');
  ctx.fillStyle = grad;
  ctx.fill();

  // Line
  ctx.beginPath();
  pts.forEach((p, i) => i === 0 ? ctx.moveTo(xp(p), yp(p.ht)) : ctx.lineTo(xp(p), yp(p.ht)));
  ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 2.5; ctx.stroke();

  // Swell component overlay
  const swellPts = hours.filter(h => h.swellHeight != null).map(h => ({
    t: new Date(h.time), ht: h.swellHeight * 3.28084
  }));
  if (swellPts.length) {
    ctx.beginPath();
    swellPts.forEach((p, i) => i === 0 ? ctx.moveTo(xp(p), yp(p.ht)) : ctx.lineTo(xp(p), yp(p.ht)));
    ctx.strokeStyle = '#16a34a'; ctx.lineWidth = 1.5; ctx.setLineDash([5, 3]); ctx.stroke();
    ctx.setLineDash([]);
  }

  // Now line
  const now = Date.now();
  const nowX = pad.l + (now - tMin) / tRange * cW;
  if (nowX >= pad.l && nowX <= W - pad.r) {
    ctx.strokeStyle = '#dc2626'; ctx.lineWidth = 1.5; ctx.setLineDash([3, 3]);
    ctx.beginPath(); ctx.moveTo(nowX, pad.t); ctx.lineTo(nowX, H - pad.b); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#dc2626'; ctx.font = 'bold 9px "DM Mono"';
    ctx.fillText('NOW', nowX + 3, pad.t + 10);
  }

  // Legend
  ctx.font = '9px "DM Mono"'; ctx.setLineDash([]);
  ctx.fillStyle = '#2563eb'; ctx.fillRect(W - 130, pad.t + 4, 12, 2); ctx.fillText('Total', W - 114, pad.t + 8);
  if (swellPts.length) {
    ctx.fillStyle = '#16a34a'; ctx.setLineDash([3, 2]);
    ctx.beginPath(); ctx.moveTo(W - 130, pad.t + 17); ctx.lineTo(W - 118, pad.t + 17); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillText('Swell', W - 114, pad.t + 20);
  }
}

// =========================================================================
// Canvas: Tide Chart (smooth spline + hi/lo markers + night shading)
// =========================================================================
function drawTides(predictions, hilo, station) {
  const canvas = $('tideCanvas');
  const dpr = window.devicePixelRatio || 1;
  const W = Math.max(700, canvas.parentElement.getBoundingClientRect().width);
  const H = 200;
  canvas.style.width = W + 'px';
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  if (!predictions || !predictions.length) {
    ctx.fillStyle = '#999'; ctx.font = '13px "DM Mono"';
    ctx.fillText('No tide data available', 20, H / 2);
    return;
  }

  const vals = predictions.map(p => ({ t: new Date(p.t), v: parseFloat(p.v) }));
  const minV = Math.min(...vals.map(v => v.v));
  const maxV = Math.max(...vals.map(v => v.v));
  const range = maxV - minV || 1;
  const tMin = vals[0].t.getTime(), tMax = vals[vals.length - 1].t.getTime();
  const tRange = tMax - tMin || 1;

  const pad = { t: 20, b: 35, l: 44, r: 14 };
  const cW = W - pad.l - pad.r, cH = H - pad.t - pad.b;
  const xp = v => pad.l + (v.t.getTime() - tMin) / tRange * cW;
  const yp = v => pad.t + cH - (v.v - minV) / range * cH;

  // Night shading
  if (station) drawNightBands(ctx, station.lat, station.lon, tMin, tMax, tRange, pad.l, pad.r, pad.t, pad.b, W, H);

  // Day grid
  ctx.strokeStyle = '#e5e1db'; ctx.lineWidth = 0.5;
  const startDay = new Date(vals[0].t); startDay.setHours(0, 0, 0, 0);
  for (let d = new Date(startDay); d.getTime() <= tMax; d.setDate(d.getDate() + 1)) {
    const dx = pad.l + (d.getTime() - tMin) / tRange * cW;
    if (dx > pad.l && dx < W - pad.r) {
      ctx.beginPath(); ctx.moveTo(dx, pad.t); ctx.lineTo(dx, H - pad.b); ctx.stroke();
      ctx.fillStyle = '#666'; ctx.font = '10px "DM Mono"';
      ctx.fillText(d.toLocaleDateString('en', { weekday: 'short', month: 'short', day: 'numeric' }), dx + 3, H - pad.b + 14);
    }
  }

  // Y labels
  ctx.fillStyle = '#999'; ctx.font = '10px "DM Mono"'; ctx.textAlign = 'right';
  for (let v = Math.ceil(minV * 2) / 2; v <= maxV + 0.25; v += 0.5) {
    const yy = pad.t + cH - (v - minV) / range * cH;
    if (yy > pad.t && yy < H - pad.b) ctx.fillText(v.toFixed(1) + 'ft', pad.l - 5, yy + 3);
  }
  ctx.textAlign = 'left';

  // Smooth bezier spline
  ctx.beginPath();
  ctx.moveTo(xp(vals[0]), yp(vals[0]));
  for (let i = 1; i < vals.length; i++) {
    const prev = vals[i - 1];
    const curr = vals[i];
    const cpx = (xp(prev) + xp(curr)) / 2;
    ctx.bezierCurveTo(cpx, yp(prev), cpx, yp(curr), xp(curr), yp(curr));
  }
  ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 2.5; ctx.stroke();

  // Fill under
  ctx.lineTo(xp(vals[vals.length - 1]), H - pad.b);
  ctx.lineTo(xp(vals[0]), H - pad.b);
  ctx.closePath();
  const grad = ctx.createLinearGradient(0, pad.t, 0, H - pad.b);
  grad.addColorStop(0, 'rgba(37,99,235,0.12)');
  grad.addColorStop(1, 'rgba(37,99,235,0.01)');
  ctx.fillStyle = grad;
  ctx.fill();

  // Hi/Lo markers
  if (hilo && hilo.length) {
    hilo.forEach(h => {
      const pt = { t: new Date(h.t), v: parseFloat(h.v) };
      const x = xp(pt), y = yp(pt);
      if (x < pad.l || x > W - pad.r) return;
      const isHigh = h.type === 'H';
      ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI * 2);
      ctx.fillStyle = isHigh ? '#2563eb' : '#ca8a04'; ctx.fill();
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();

      // Label
      ctx.fillStyle = isHigh ? '#2563eb' : '#92700c';
      ctx.font = 'bold 9px "DM Mono"'; ctx.textAlign = 'center';
      const tStr = pt.t.toLocaleTimeString('en', { hour: 'numeric', minute: '2-digit', hour12: true });
      ctx.fillText(`${pt.v.toFixed(1)}ft`, x, isHigh ? y - 10 : y + 16);
      ctx.fillStyle = '#999'; ctx.font = '8px "DM Mono"';
      ctx.fillText(tStr, x, isHigh ? y - 20 : y + 25);
      ctx.textAlign = 'left';
    });
  }

  // Now line
  const now = Date.now();
  const nowX = pad.l + (now - tMin) / tRange * cW;
  if (nowX > pad.l && nowX < W - pad.r) {
    ctx.strokeStyle = '#dc2626'; ctx.lineWidth = 1.5; ctx.setLineDash([3, 3]);
    ctx.beginPath(); ctx.moveTo(nowX, pad.t); ctx.lineTo(nowX, H - pad.b); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#dc2626'; ctx.font = 'bold 9px "DM Mono"';
    ctx.fillText('NOW', nowX + 3, pad.t + 10);
  }
}

// =========================================================================
// Canvas: Swell Energy Spectrum
// =========================================================================
function drawSpectrum(spectral) {
  const canvas = $('spectrumCanvas');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 220 * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  const W = rect.width, H = 220;

  if (!spectral || !spectral.length) {
    ctx.fillStyle = '#999'; ctx.font = '13px "DM Mono"';
    ctx.fillText('No spectral data available', 20, H / 2);
    return;
  }

  // Sort by period descending (so x axis goes high period ‚Üí low period, i.e. left=long, right=short)
  const sorted = [...spectral].sort((a, b) => b.period_s - a.period_s);
  const maxE = Math.max(...sorted.map(s => s.energy));
  const minP = Math.min(...sorted.map(s => s.period_s));
  const maxP = Math.max(...sorted.map(s => s.period_s));

  const pad = { t: 30, b: 40, l: 50, r: 14 };
  const cW = W - pad.l - pad.r, cH = H - pad.t - pad.b;

  // Title
  ctx.fillStyle = '#999'; ctx.font = '10px "DM Mono"'; ctx.textAlign = 'center';
  ctx.fillText('Wave Energy (m¬≤/Hz) vs Period (s)', W / 2, 16);
  ctx.textAlign = 'left';

  // Grid
  ctx.strokeStyle = '#e5e1db'; ctx.lineWidth = 0.5;
  // Y grid
  const eStep = maxE > 2 ? Math.ceil(maxE / 5) : maxE / 5;
  for (let e = 0; e <= maxE * 1.1; e += eStep || 0.1) {
    const yy = pad.t + cH - (e / (maxE * 1.1)) * cH;
    ctx.beginPath(); ctx.moveTo(pad.l, yy); ctx.lineTo(W - pad.r, yy); ctx.stroke();
    ctx.fillStyle = '#999'; ctx.font = '9px "DM Mono"'; ctx.textAlign = 'right';
    ctx.fillText(e.toFixed(1), pad.l - 5, yy + 3);
  }
  // X grid
  const pStep = maxP > 15 ? 4 : 2;
  for (let p = Math.ceil(minP); p <= maxP; p += pStep) {
    const xx = pad.l + ((p - minP) / (maxP - minP)) * cW;
    ctx.beginPath(); ctx.moveTo(xx, pad.t); ctx.lineTo(xx, H - pad.b); ctx.stroke();
    ctx.fillStyle = '#999'; ctx.font = '9px "DM Mono"'; ctx.textAlign = 'center';
    ctx.fillText(p + 's', xx, H - pad.b + 14);
  }
  ctx.textAlign = 'left';

  // Axis labels
  ctx.fillStyle = '#777'; ctx.font = '9px "DM Mono"'; ctx.textAlign = 'center';
  ctx.fillText('Period (s)', W / 2, H - 4);
  ctx.save(); ctx.translate(12, H / 2); ctx.rotate(-Math.PI / 2);
  ctx.fillText('Energy (m¬≤/Hz)', 0, 0);
  ctx.restore(); ctx.textAlign = 'left';

  // Plot sorted by period ascending for the line
  const byPeriod = [...spectral].sort((a, b) => a.period_s - b.period_s);
  const xOf = s => pad.l + ((s.period_s - minP) / (maxP - minP)) * cW;
  const yOf = s => pad.t + cH - (s.energy / (maxE * 1.1)) * cH;

  // Area fill
  ctx.beginPath();
  byPeriod.forEach((s, i) => i === 0 ? ctx.moveTo(xOf(s), yOf(s)) : ctx.lineTo(xOf(s), yOf(s)));
  ctx.lineTo(xOf(byPeriod[byPeriod.length - 1]), H - pad.b);
  ctx.lineTo(xOf(byPeriod[0]), H - pad.b);
  ctx.closePath();
  const grad = ctx.createLinearGradient(0, pad.t, 0, H - pad.b);
  grad.addColorStop(0, 'rgba(37,99,235,0.2)');
  grad.addColorStop(1, 'rgba(37,99,235,0.02)');
  ctx.fillStyle = grad;
  ctx.fill();

  // Line
  ctx.beginPath();
  byPeriod.forEach((s, i) => i === 0 ? ctx.moveTo(xOf(s), yOf(s)) : ctx.lineTo(xOf(s), yOf(s)));
  ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 2; ctx.stroke();

  // Peak dot
  const peak = byPeriod.reduce((a, b) => a.energy > b.energy ? a : b);
  ctx.beginPath(); ctx.arc(xOf(peak), yOf(peak), 5, 0, Math.PI * 2);
  ctx.fillStyle = '#dc2626'; ctx.fill();
  ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
  ctx.fillStyle = '#dc2626'; ctx.font = 'bold 9px "DM Mono"'; ctx.textAlign = 'center';
  ctx.fillText(`${peak.period_s}s`, xOf(peak), yOf(peak) - 10);
  ctx.textAlign = 'left';
}

// =========================================================================
// Canvas: Compass Rose
// =========================================================================
function drawCompass(spectral) {
  const canvas = $('compassCanvas');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 320 * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  const W = rect.width, H = 320;
  const cx = W / 2, cy = H / 2, R = Math.min(W, H) / 2 - 35;

  // Concentric rings with labels
  for (let i = 1; i <= 4; i++) {
    ctx.beginPath(); ctx.arc(cx, cy, R * i / 4, 0, Math.PI * 2);
    ctx.strokeStyle = '#e5e1db'; ctx.lineWidth = 0.5; ctx.stroke();
  }

  // All 8 directions
  const cardinals = [
    { l: 'N', a: -90 }, { l: 'NE', a: -45 }, { l: 'E', a: 0 }, { l: 'SE', a: 45 },
    { l: 'S', a: 90 }, { l: 'SW', a: 135 }, { l: 'W', a: 180 }, { l: 'NW', a: -135 }
  ];
  ctx.fillStyle = '#777'; ctx.font = '11px "DM Mono"'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  cardinals.forEach(d => {
    const a = d.a * Math.PI / 180;
    ctx.fillText(d.l, cx + (R + 22) * Math.cos(a), cy + (R + 22) * Math.sin(a));
    ctx.beginPath(); ctx.moveTo(cx, cy);
    ctx.lineTo(cx + R * Math.cos(a), cy + R * Math.sin(a));
    ctx.strokeStyle = '#e5e1db'; ctx.lineWidth = 0.5; ctx.stroke();
  });
  ctx.textBaseline = 'alphabetic';

  if (!spectral || !spectral.length) {
    ctx.fillStyle = '#999'; ctx.font = '12px "DM Mono"';
    ctx.fillText('No spectral data', cx, cy);
    return;
  }

  const maxE = Math.max(...spectral.map(s => s.energy));

  // Energy magnitude labels on rings
  ctx.fillStyle = '#bbb'; ctx.font = '8px "DM Mono"'; ctx.textAlign = 'left';
  for (let i = 1; i <= 4; i++) {
    ctx.fillText((maxE * i / 4).toFixed(1), cx + 4, cy - R * i / 4 + 10);
  }

  // Draw filled wedges with spread
  spectral.forEach(s => {
    const angle = (s.direction_deg - 90) * Math.PI / 180;
    const r = (s.energy / maxE) * R * 0.9;
    const halfW = 4 * Math.PI / 180;

    ctx.beginPath(); ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, r, angle - halfW, angle + halfW);
    ctx.closePath();

    // Color by period: short (warm) ‚Üí long (cool)
    const periodNorm = Math.min((s.period_s || 5) / 18, 1);
    const hue = 200 + periodNorm * 40; // 200-240 blue range
    const alpha = 0.35 + periodNorm * 0.45;
    ctx.fillStyle = `hsla(${hue}, 80%, 50%, ${alpha})`;
    ctx.fill();

    if (s.energy > maxE * 0.3 && s.period_s) {
      ctx.fillStyle = '#333'; ctx.font = '9px "DM Mono"'; ctx.textAlign = 'center';
      ctx.fillText(`${s.period_s}s`, cx + (r + 14) * Math.cos(angle), cy + (r + 14) * Math.sin(angle) + 3);
    }
  });

  // Legend
  ctx.textAlign = 'left';
  ctx.font = '8px "DM Mono"'; ctx.fillStyle = '#999';
  ctx.fillText('Color: short period (light) ‚Üí long period (dark)', 8, H - 6);
}

// =========================================================================
// Hourly Forecast Table
// =========================================================================
function renderHourlyTable(hours) {
  if (!hours || !hours.length) {
    $('hourly-table').innerHTML = '<p class="error-msg">No forecast data</p>';
    return;
  }
  const now = Date.now();
  const upcoming = hours.filter(h => new Date(h.time).getTime() >= now - 3600000).slice(0, 48);
  let html = `<table class="forecast-table">
    <thead><tr><th>Time</th><th>Ht</th><th>Per</th><th>Dir</th><th>Swell</th></tr></thead><tbody>`;
  upcoming.forEach(h => {
    const t = new Date(h.time);
    const tStr = t.toLocaleString('en', { weekday: 'short', hour: 'numeric', hour12: true });
    const ht = h.waveHeight != null ? (h.waveHeight * 3.28084).toFixed(1) + 'ft' : '‚Äî';
    const per = h.wavePeriod != null ? h.wavePeriod.toFixed(0) + 's' : '‚Äî';
    const dir = h.waveDir != null ? degToCompass(h.waveDir) : '‚Äî';
    const sw = h.swellHeight != null ? (h.swellHeight * 3.28084).toFixed(1) + 'ft' : '‚Äî';
    html += `<tr><td>${tStr}</td><td>${ht}</td><td>${per}</td><td>${dir}</td><td>${sw}</td></tr>`;
  });
  html += '</tbody></table>';
  $('hourly-table').innerHTML = html;
}

// =========================================================================
// Init
// =========================================================================
async function init() {
  await loadStations();
  initMap();
  initSearch();
}
init();
</script>
</body>
</html>
